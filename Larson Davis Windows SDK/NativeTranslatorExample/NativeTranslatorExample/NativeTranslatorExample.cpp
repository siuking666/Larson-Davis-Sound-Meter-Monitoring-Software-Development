/**************************************************************************//**
 * @file NativeTranslator.cpp
 * @brief Example of how to use the Translator Wrapper. This example will print
 *        out the Time History values from the float array.
 *        To see what is available inspect the header file to see which headers
 *        must be included.
 * @version 1.0.0
 * @author Kevin Lawrence
 ******************************************************************************
 * @section License
 * < b > (C)Copyright 2021 Larson Davis, A PCB Piezotronics Div.</ b >
 *
******************************************************************************/

#include <iostream>
#include <vector>


// This file is required for importing the dll
//#include "ApiHeader.h"

//#include "Array_uint8_t.h"
//#include "CSlmRecord.h"
//#include "CSlmLegacy.h"
//#include "CLDConstants.h"
//#include <CLDConstants.h>
// Translator explicitly calls out CILDRecord and vector.

#include "LDTranslator.h"
#include "NativeTranslatorExample.h"

using namespace std;
using namespace LarsonDavis::Native;

void DisplayTimeHistory(CSlmRecord* pRec)
{
   auto pThManager = pRec->THMngr();
   if (pThManager != nullptr)
   {
      wcout << L"TH Rec Count: " << pThManager->NumTHRecords() << endl;
      auto pThRecs = pThManager->THRecs();
      if (NULL != pThRecs)
      {
         for (int j = 0; j < pThManager->NumTHRecords(); ++j)
         {
            auto pThRec = pThRecs->Item(j);
            if (NULL != pThRec)
            {
               auto pThVals = pThRec->THFloatVals();
               if (NULL != pThVals)
               {
                  wcout << "TH Rec " << j << ": ";
                  for (int k = 0; k < pThVals->Length(); ++k)
                  {
                     wcout << pThVals->Get(k) << " ";
                  }
                  wcout << endl;
               }
            }
         }
      }
   }
}

void DisplaySessionLog(CSlmRecord* pRec)
{
   auto pSessionLog = pRec->SessionLog();
   if (pSessionLog != nullptr)
   {
      wcout << L"Session Log" << endl;
      auto pRunRecords = pSessionLog->RunRecords();
      if (NULL != pRunRecords)
      {
         for (int i = 0; i < pRunRecords->Count(); ++i)
         {
            wcout << L"Run Record " << (i + 1) << ": Time=" << pRunRecords->Item(i)->RecordDate() << ", Type=" << *CSessionLog::GetLogAction(pRunRecords->Item(i)->Type()) << ", Cause=" << (int)pRunRecords->Item(i)->Cause();
            if (pRunRecords->Item(i)->AudioDataIndex() > 0)
            {
               wcout << "Audio Record (" << pRunRecords->Item(i)->AudioDataIndex() << ")";
            }

            wcout << endl;
         }
      }
      auto pAudioData = pSessionLog->AudioData();
      if (NULL != pAudioData)
      {
         for (int i = 0; i < pAudioData->Count(); ++i)
         {
            auto pSRec = pAudioData->Item(i);
            auto format = pSRec->Format();
            auto pSRecData = pSRec->Data();
            int32_t len = pSRecData->Length();
            uint8_t* pBuffer = new uint8_t[len];
            memset(pBuffer, 0, pSRecData->Length());
            pSRecData->CopyTo(pBuffer, 44u);
            if (format == EAudioFormat::Wave)
            {
               wcout << "Sound Record " << i + 1 << " (WAVE," << pSRecData->Length() << " bytes)" << endl;
               // Fully formated wav file including the header
               // Can be written to the hard drive as a .wav file and will be playable by any wav player.
            }
            else if (format == EAudioFormat::Ogg)
            {
               wcout << "Sound Record " << i + 1 << " (Ogg/Vorbis" << pSRecData->Length() << " bytes)" << endl;
               // Fully formatted Ogg/Vorbis file.
               // Can be written to the hard drive as a .ogg file and will be playable by compatible ogg palyers.
            }
            else if (format == EAudioFormat::Raw)
            {
               wcout << "Sound Record " << i + 1 << " (Raw, " << pSRecData->Length() << " bytes)" << endl;
               // No longer matters as the bytes have already been reordered if retrieved using the Data method of the CSoundRecord class.
               // If using the offset and length then the bytes will need to be reordered.
               // Voice recording do not have any pre-trigger but may need inspection
               // No header is present in the file and so will need to be written.
               // All SoundRecords generated by 831A, LxT, LxT SE, up to but not including the 831C use this format.
            }
            delete[] pBuffer;
         }
      }
   }
}

void DisplayCalCheckHistory(CSlmRecord* pRec)
{
   auto calCheckHist = pRec->CalCheckHistory();
   auto dataCollection = calCheckHist->data();
   auto standardLevelCollection = calCheckHist->standardLevel();
   wcout << "CalCheck History" << endl;
   for (int i = 0; i < dataCollection->Length(); ++i)
   {
      auto calData = dataCollection->Get(i);
      if (calData->calibrationDate() > 0)
      {
         auto stdLevel = standardLevelCollection->Get(i);
         int bins = calData->bins();
         float val = 0, diff = 0;
         pRec->GetEACalCheck(calData, stdLevel, val, diff);
         auto name = CSlmLegacy::GetPreampName(pRec->MeterType(), (EPreampType)calData->preampType());
         wcout << *name << " " << val << " " << diff << endl;
         if (CLDConstants::FullOctaveBins() == bins || CLDConstants::ThirdOctaveBins() == bins)
         {

         }
      }
   }
}

void DisplayCommonSlm(CSlmRecord* pRec)
{
   ILDRecord* pIRec = pRec;
   wcout << "Display common parts for all SLM Files" << endl << "File Name: " << *pIRec->DataFileName() << endl;
   DisplaySessionLog(pRec);
   DisplayCalCheckHistory(pRec);
}

void DisplayRt60Record(CSlmRecord* pRec)
{
   wcout << L"Display RT60 Record" << endl;
   auto events = pRec->Events();
   wcout << "Event Count: " << events->Count() << endl;
   if (events != nullptr && events->Count() > 0)
   {
      if (events->Item(0)->ETHData() != nullptr)
      {
         auto recs = events->Item(0)->ETHData()->ETHRecs();
         if (recs != nullptr && recs->Length())
         {
            auto oba = recs->Item(0)->oba();
            wcout << "OBA size: " << oba->Length() << endl;
            if (oba != nullptr)
            {
               wcout << "OBA: ";

               for (int i = 0; i < oba->Length(); ++i)
               {
                  if (i > 0)
                  {
                     wcout << ", ";
                  }
                  wcout << oba->Item(i);
               }

               wcout << endl;
            }
         }
      }
   }
}

void DisplaySlmRecord(CSlmRecord* pRec)
{
   wcout << L"Display Slm Record" << endl;
}

void DisplayFftRecord(CSlmRecord* pRec)
{
   wcout << L"Display FFT Record" << endl;
   auto pFftHistory = pRec->FftHistory();
   if (pFftHistory != nullptr)
   {
      for (int i = 0; i < pFftHistory->Count(); ++i)
      {
         auto pFftMeasurement = pFftHistory->Item(i);
         if (nullptr != pFftMeasurement)
         {
            auto pFft = pFftMeasurement->Fft();
            wcout << "Fft Meas " << i << ": " << pFft->stLevels()->levelAvg()->Length() << endl;
         }
      }
   }
}

int main(int argc, char* argv[])
{
   if (argc <= 1) // We need a file name to translate
   {
      wcout << L"Pass the path for the file to translate on the command line" << endl;
   }
   else
   {
      // Translate returns a vector of CILDRecor pointers.
      size_t len = strlen(argv[1]);
      wstring path(argv[1], argv[1] + len);

      try
      {
         auto result = Translate(path.c_str());

         if (result->Type == RecType_SlmFile || result->Type == RecType_FftFile || result->Type == RecType_Rt60File)
         {
            ReadSlmRecord(result);
         }
         else if (result->Type == RecType_SpaFile || result->Type == RecType_X21File)
         {
            ReadSpartanRecord(result);
         }
      }
      catch (CTranslatorException& ex)
      {
         wcout << *ex.ManagedTypeName << endl << *ex.Message << endl << *ex.StackTrace << endl;
      }
   }
   system("PAUSE");

   return 0;
}

void ReadSlmRecord(std::shared_ptr<LarsonDavis::Native::CTranslationResult>& result)
{
   for (uint32_t i = 0u; i < result->RecordCount; ++i)
   {
      // To be able to access SlmRecord specific functions, properties, and field you need to "dynamic_cast<CSlmRecord*>"
      // Note that pSlmRec will not keep the managed instance alive by itself (similar to a weak reference in C#, you need to have a shared pointer to it.
      CSlmRecord* pSlmRec = dynamic_cast<CSlmRecord*>(result->pRecords[i].get());
      // To get a shared pointer use dynamic_pointer_cast<CSlmRecord>
      auto pOwning = dynamic_pointer_cast<CSlmRecord>(result->pRecords[i]);

      if (pSlmRec == pOwning.get())
      {
         wcout << L"They are the same value" << endl;
      }

      if (NULL != pSlmRec)
      {
         DisplayCommonSlm(pSlmRec);

         switch (pSlmRec->Mode())
         {
         case EInstrumentMode::Slm:
            DisplaySlmRecord(pSlmRec);
            break;
         case EInstrumentMode::RT60:
            DisplayRt60Record(pSlmRec);
            break;
         case EInstrumentMode::Fft:
            DisplayFftRecord(pSlmRec);
            break;
         default:
            return; // This is unreachable.
         }
         // EXAMPLE SHOWING HOW STRINGS WILL WORK

         // Immediately uses the character pointer to construct a string just before the pointer goes out of scope
         wstring name = *(result->pRecords[i]->DataFileName());

         // Creates a copy of the wrapper which will be valid until it goes out of scope
         StringWrapper wrapper = result->pRecords[i]->DataFileName();

         // Using the wrapper above this pointer will stay valid as long as the wrapper stays in scope.
         const wchar_t* pName = *wrapper;

         // This is a pointer to a memory block that will become invalid immediately after this line executes.
         const wchar_t* pBroken = *(result->pRecords[i]->DataFileName());

         StringWrapper overallTitle = pSlmRec->OverallTitle();
         StringWrapper jobDesc = pSlmRec->JobDescription();

         // This wrapper exists on the heap so it and its pointer will be valid until explicitly deleted
         StringWrapper* pWrapper = new StringWrapper(wrapper);
         auto metaRec = pSlmRec->MetaRec();
      }
   }
}

void ReadSpartanRecord(std::shared_ptr<LarsonDavis::Native::CTranslationResult>& result)
{
   for (uint32_t i = 0u; i < result->RecordCount; ++i)
   {
      // To be able to access SlmRecord specific functions, properties, and field you need to "dynamic_cast<CSlmRecord*>"
      // Note that pSlmRec will not keep the managed instance alive by itself (similar to a weak reference in C#, you need to have a shared pointer to it.
      CSpartanRecord* pSpartanRec = dynamic_cast<CSpartanRecord*>(result->pRecords[i].get());
      // To get a shared pointer use dynamic_pointer_cast<CSlmRecord>
      auto pOwning = dynamic_pointer_cast<CSpartanRecord>(result->pRecords[i]);

      if (pSpartanRec == pOwning.get())
      {
         wcout << L"They are the same value" << endl;
      }

      if (NULL != pSpartanRec)
      {
         wcout << L"Dose is: " << pSpartanRec->Dose() << endl;
         wcout << L"Metric is: " << pSpartanRec->Metric1Level() << endl;
         wcout << L"Name is:" << *pSpartanRec->FilePath() << endl;
         wcout << L"Time History info: " << pSpartanRec->TimeHistory()->Count() << endl;
         for (size_t i = 0; i < pSpartanRec->TimeHistory()->Count(); i++)
         {
            auto entry = pSpartanRec->TimeHistory()->Item((int32_t)i);
            wcout << i << " Leq: " <<  entry->Laeq() << endl;
         }
      }
   }
}
